using System.CodeDom.Compiler;
using System.Collections.Frozen;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace ETL.WorkerD.Gen;

/// <summary>
/// A source generator that creates set of queries and calls to perform Postgres COPY with Npgsql connector.
/// The target model class should be annotated with the 'Generators.PgLoadModelAttribute' attribute.
/// </summary>
// This attribute is required despite highlighting
[Generator(LanguageNames.CSharp)]
public class PgCopySourceGenerator : IIncrementalGenerator
{
    private const string GeneratorNamespace = "ETL.PgLoadGen";
    
    private const string ModelAttributeName = "PgLoadModelAttribute";
    private const string ModelAttributeSourceCode = $@"// <auto-generated/>

namespace {GeneratorNamespace};

[System.AttributeUsage(System.AttributeTargets.Class)]
public class {ModelAttributeName}(string TableName) : System.Attribute
{{
}}";
    
    private const string KeyAttributeShortName = "PgLoadKey";
    private const string KeyAttributeName = $"{KeyAttributeShortName}Attribute";
    private const string KeyAttributeSourceCode = $@"// <auto-generated/>

namespace {GeneratorNamespace};

[System.AttributeUsage(System.AttributeTargets.Property)]
public class {KeyAttributeName} : System.Attribute
{{
}}";
    
    private const string InterfaceName = "IPgCopier";
    private const string InterfaceSourceCode = $@"// <auto-generated/>
using System.Threading;
using System.Threading.Tasks;
using Npgsql;

namespace {GeneratorNamespace};

public interface {InterfaceName}<T>
{{
    string CreateTempTableSql {{ get; }}
    string CopySql {{ get; }}
    string UpsertSql {{ get; }}
    Task WriteAsync(NpgsqlBinaryImporter writer, T row, CancellationToken ct);
}}";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Add the attributes and interface to the compilation.
        context.RegisterPostInitializationOutput(static ctx =>
        {
            // Add attribute used to mark model
            ctx.AddSource($"{ModelAttributeName}.g.cs", SourceText.From(ModelAttributeSourceCode, Encoding.UTF8));
            // Add attribute used to mark key columns
            ctx.AddSource($"{KeyAttributeName}.g.cs", SourceText.From(KeyAttributeSourceCode, Encoding.UTF8));
            // Add interface of generated class
            ctx.AddSource($"{InterfaceName}.g.cs", SourceText.From(InterfaceSourceCode, Encoding.UTF8));
        });

        // Filter classes annotated with the [PgLoadModel] attribute and transform to required model data.
        var provider = context.SyntaxProvider
            // Filtering by attribute with ForAttributeWithMetadataName() is recommended,
            // as it is much faster than most of what we can write.
            .ForAttributeWithMetadataName(
                fullyQualifiedMetadataName: $"{GeneratorNamespace}.{ModelAttributeName}",
                predicate: static (s, _) => s is ClassDeclarationSyntax,
                // Notice, that result of Transform() should be comparable.
                // To achieve this you can use record types or value types...
                transform: static (ctx, ct) => Transform((INamedTypeSymbol)ctx.TargetSymbol, 
                    (ClassDeclarationSyntax)ctx.TargetNode, ctx.Attributes))
            // ... or provide custom equality comparer.
            .WithComparer(new ModelInfoEqualityComparer())
            // If you require complex transformation or filtering logic - it is recommended to extract useful info
            // early and filter frequently. If you do so, unchanging data will be detected early,
            // and work down the line - skipped. Here we filter out classes with incomplete data.
            .Where(x => !string.IsNullOrWhiteSpace(x.Name));
        
        // Generate the source code.
        context.RegisterSourceOutput(provider, GenerateCode);
    }

    /// <summary>
    /// Extract class and property info from syntactic and semantic models. 
    /// </summary>
    /// <param name="symbol">Semantic model, which explains what does this syntax means within current context</param>
    /// <param name="classNode">Syntax model with syntactic and lexical info</param>
    /// <param name="attributeData">[PgLoadModel] attribute data</param>
    /// <returns></returns>
    private static ModelInfo Transform(INamedTypeSymbol symbol, ClassDeclarationSyntax classNode, ImmutableArray<AttributeData> attributeData)
    {
        // Inspecting attribute constructor arguments directly to get target table name
        var tableName = attributeData[0].ConstructorArguments[0].Value as string;

        // Table name not specified - skip remaining work
        if (string.IsNullOrWhiteSpace(tableName))
        {
            return new();
        }
        
        // Inspecting class properties using syntactic model. Using semantic model may be more robust,
        // but also a bigger pain.
        var props = classNode.Members.OfType<PropertyDeclarationSyntax>();
        HashSet<PropertyInfo> propsInfo = [];

        foreach (var prop in props)
        {
            var name = prop.Identifier.Text;
            
            // Search for [PgLoadKey] attribute to determine, if property is marked as a Key.
            // I recommend to use similar approach, if you will want to add other metadata,
            // like overriding NpgsqlType, ignoring props, or declaring different keys for delete operation.
            var isKey = prop.AttributeLists.Any(y => 
                y.DescendantNodes().OfType<IdentifierNameSyntax>().Any(z => z.Identifier.Text == KeyAttributeShortName));
            
            // To handle qualified types like "System.DateTime" we get last node of specific kinds.
            var type = prop.DescendantNodes()
                .LastOrDefault(x => x.IsKind(SyntaxKind.PredefinedType) || x.IsKind(SyntaxKind.IdentifierName));
            var typeName = type switch
            {
                PredefinedTypeSyntax pts => pts.Keyword.Text,
                IdentifierNameSyntax ins => ins.Identifier.Text,
                _ => string.Empty
            };
            NetTypeNpgsqlTypeMap.TryGetValue(typeName, out var npgsqlType);
            
            if (npgsqlType is not null)
            {
                propsInfo.Add(new PropertyInfo(name, npgsqlType, isKey));
            }
        }
        
        // Something wrong with properties - skip remaining work
        if (propsInfo.Count == 0 || !propsInfo.Any(x => x.IsKey))
        {
            return new();
        }
        
        var className = classNode.Identifier.Text;
        var @namespace = symbol.ContainingNamespace.IsGlobalNamespace
            ? null
            : symbol.ContainingNamespace.ToDisplayString();

        return new(className, @namespace, tableName!, propsInfo);
    }
    
    /// <summary>
    /// Generate code. Ideally you would want to handle edge cases, like when all columns are keys,
    /// but we will ignore them for simplicity.
    /// </summary>
    /// <param name="context">Source generation context used to add source files.</param>
    /// <param name="modelInfo">Model info required to generate IPgLoadHandler implementation.</param>
    private void GenerateCode(SourceProductionContext context, ModelInfo modelInfo)
    {
        // Prepare SQL statements from prop data
        var columns = string.Join(", ", modelInfo.PropsInfo.Select(x => x.Name));
        var keyColumns  = string.Join(", ", modelInfo.PropsInfo.Where(x => x.IsKey).Select(x => x.Name));
        var notKeys = modelInfo.PropsInfo.Where(x => !x.IsKey).Select(x => x.Name);
        var setStatement = string.Join(", ", notKeys.Select(x => $"{x} = excluded.{x}"));
        
        // We will use IndentedTextWriter to generate correctly indented code.
        // For simpler cases (i.e. without cycles) - you can use simple interpolated strings.
        StringBuilder builder = new();
        using StringWriter writer = new(builder, CultureInfo.InvariantCulture);
        using IndentedTextWriter d = new(writer, "    ");
        
        d.WriteLine("// <auto-generated/>");
        d.WriteLineNoTabs(null!);
        
        d.WriteLine("using System;");
        d.WriteLine("using System.Collections.Frozen;");
        d.WriteLine("using Npgsql;");
        d.WriteLine("using NpgsqlTypes;");
        d.WriteLineNoTabs(null!);

        if (modelInfo.Namespace is not null)
        {
            d.WriteLine($"namespace {modelInfo.Namespace};");
            d.WriteLineNoTabs(null!);
        }
        
        d.WriteLine($"public class {modelInfo.Name}Copier : {GeneratorNamespace}.{InterfaceName}<{modelInfo.Name}>");
        d.WriteLine("{");
        d.Indent++;
        d.WriteLine("public string CreateTempTableSql =>");
        d.Indent++;
        d.WriteLine($"\"CREATE TEMP TABLE tmpt AS SELECT {columns} FROM {modelInfo.TableName} LIMIT 0 WITH NO DATA;\";");
        d.Indent--;
        d.WriteLine($"public string CopySql => \"COPY tmpt ({columns}) FROM STDIN (FORMAT BINARY);\";");
        d.WriteLine("public string UpsertSql =>");
        d.Indent++;
        d.WriteLine("$\"\"\"");
        d.WriteLine($"INSERT INTO {modelInfo.TableName} ({columns})");
        d.WriteLine($"SELECT {columns}");
        d.WriteLine("FROM tmpt");
        d.WriteLine($"ON CONFLICT ({keyColumns}) ");
        d.WriteLine($"DO UPDATE SET {setStatement};");
        d.WriteLine("\"\"\";");
        d.Indent--;
        d.WriteLine($"public async Task WriteAsync(NpgsqlBinaryImporter writer, {modelInfo.Name} row, CancellationToken ct)");
        d.WriteLine("{");
        d.Indent++;
        d.WriteLine("await writer.StartRowAsync(ct);");

        foreach (var propInfo in modelInfo.PropsInfo)
        {
            d.WriteLine($"await writer.WriteAsync(row.{propInfo.Name}, NpgsqlDbType.{propInfo.NpgsqlType}, ct);");
        }
        
        d.Indent--;
        d.WriteLine("}");
        d.Indent--;
        d.WriteLine("}");

        // Add the source code to the compilation.
        context.AddSource($"{modelInfo.Namespace ?? string.Empty}.{modelInfo.Name}Copier.g.cs",
            SourceText.From(writer.ToString(), Encoding.UTF8));
    }

    private static readonly FrozenDictionary<string, string> NetTypeNpgsqlTypeMap = new Dictionary<string, string>
    {
        ["int"] = "Integer",
        ["long"] = "Bigint",
        ["string"] = "Varchar",
        ["DateTime"] = "Timestamp"
    }.ToFrozenDictionary();

    private sealed record PropertyInfo(string Name, string NpgsqlType, bool IsKey)
    {
        public string Name { get; } = Name;
        public string NpgsqlType { get; } = NpgsqlType;
        public bool IsKey { get; } = IsKey;
    };
    
    private sealed record ModelInfo(string Name, string? Namespace, string TableName, HashSet<PropertyInfo> PropsInfo)
    {
        public ModelInfo() : this(string.Empty, null, string.Empty, [])
        {
        }
        
        public string Name { get; } = Name;
        public string? Namespace { get; } = Namespace;
        public string TableName { get; } = TableName;
        public HashSet<PropertyInfo> PropsInfo { get; } = PropsInfo;
    };

    private sealed class ModelInfoEqualityComparer : EqualityComparer<ModelInfo>
    {
        public override bool Equals(ModelInfo x, ModelInfo y)
        {
            return x.Name == y.Name
                   && x.Namespace == y.Namespace
                   && x.TableName == y.TableName
                   && x.PropsInfo.SetEquals(y.PropsInfo);
        }

        public override int GetHashCode(ModelInfo obj)
        {
            return obj.GetHashCode();
        }
    }
}